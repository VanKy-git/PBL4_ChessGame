<!doctype html>
<html lang="vi">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Chess Game</title>
    <style>
        :root{
            --size: 64px;
            --board-gap: 8px;
        }
        body{
            font-family: system-ui, Arial;
            display:flex;
            gap:24px;
            padding:24px;
            background-image: url(../resources/background5.png);
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }
        .wrapper{display:flex;flex-direction:column;align-items:center}
        .board{
            display:grid;
            grid-template-columns: repeat(8, var(--size));
            grid-template-rows: repeat(8, var(--size));
            gap:0;
            border: 4px solid #333;
            box-shadow: 0 6px 18px rgba(0,0,0,0.12);
            user-select:none;
        }
        .square{
            width:var(--size); height:var(--size);
            display:flex;align-items:center;justify-content:center;
            font-size:32px; cursor:pointer; position:relative;
        }
        .square.light{ background: #f0d9b5; }
        .square.dark{ background: #b58863; }
        .square.highlight{ outline: 4px solid rgba(50,180,50,0.6); box-sizing:border-box; }
        .square.last-move{ box-shadow: inset 0 0 0 3px rgba(255,255,0,0.4); }
        .coords{font-size:12px; position:absolute; bottom:2px; right:4px; color:rgba(0,0,0,0.35)}
        .info{
            max-width:320px;
            background:white;
            padding:20px;
            border-radius:8px;
            box-shadow:0 2px 10px rgba(0,0,0,0.1)
        }
        .status{
            font-weight:600;
            margin-bottom:12px;
            padding:8px;
            background:#e8f4fd;
            border-radius:4px;
            text-align:center
        }
        .connection-status{
            font-size:14px;
            margin-bottom:8px;
            padding:6px;
            border-radius:4px;
            text-align:center
        }
        .connected{background:#d4edda; color:#155724}
        .disconnected{background:#f8d7da; color:#721c24}
        .game-info{margin:12px 0; font-size:14px}
        .game-info div{margin:4px 0}
        #playerName{
            margin-bottom:8px;
            padding:8px;
            border:1px solid #ddd;
            border-radius:4px;
            width:100%
        }
        button{
            margin:4px 0;
            padding:8px 12px;
            border-radius:4px;
            border:1px solid #007bff;
            background:#007bff;
            color:white;
            cursor:pointer;
            width:100%
        }
        button:hover{background:#0056b3}
        button:disabled{background:#6c757d; cursor:not-allowed}
        .waiting{
            color:#856404;
            background:#fff3cd;
            border:1px solid #ffeaa7;
            padding:8px;
            border-radius:4px;
            text-align:center
        }

        /* th√™m ph·∫ßn chat + ph√≤ng */
        #roomControls input {
            margin-top: 4px;
            padding: 6px;
            width: 100%;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        #leaveRoomBtn {
            background: #dc3545;
            border: none;
        }
        #leaveRoomBtn:hover {
            background: #a91f30;
        }
        .chat-box {
            margin-top: 12px;
            border: 1px solid #ccc;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            height: 180px;
        }
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 6px;
            font-size: 14px;
            background: #fafafa;
        }
        .chat-input {
            display: flex;
            border-top: 1px solid #ccc;
        }
        .chat-input input {
            flex: 1;
            padding: 6px;
            border: none;
            outline: none;
        }
        .chat-input button {
            width: auto;
            border: none;
            background: #007bff;
            color: white;
            padding: 6px 10px;
        }
        #winMessage {
            display:none;
            padding:12px;
            background:#d4edda;
            color:#155724;
            font-weight:bold;
            text-align:center;
            border-radius:6px;
            margin-top:10px;
        }
        .hidden {
            display: none;
        }

        #promotion-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #promotion-modal {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .promotion-pieces {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }

        .promotion-piece {
            font-size: 50px; /* L√†m cho qu√¢n c·ªù Unicode l·ªõn */
            cursor: pointer;
            padding: 10px;
            border-radius: 6px;
            transition: background-color 0.2s;
        }

        .promotion-piece:hover {
            background-color: #eee;
        }
    </style>
</head>
<body>
<!--<div id="promotion-overlay" class="hidden">-->
<!--    <div id="promotion-modal">-->
<!--        <h3>Ch·ªçn qu√¢n c·ªù ƒë·ªÉ phong c·∫•p</h3>-->
<!--        <div class="promotion-pieces">-->
<!--        </div>-->
<!--    </div>-->
<!--</div>-->
<div class="wrapper">
    <div id="board" class="board" aria-label="Chess board"></div>
</div>

<div class="info">
    <div id="connectionStatus" class="connection-status disconnected">Ch∆∞a k·∫øt n·ªëi</div>

    <div id="loginSection">
        <input type="text" id="playerName" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n" value="Player1">
        <button id="connectBtn">K·∫øt n·ªëi</button>
    </div>

    <div id="gameSection" style="display:none">
        <div class="status" id="status">ƒêang ch·ªù...</div>

        <div class="game-info">
            <div><strong>Ph√≤ng:</strong> <span id="roomInfo">-</span></div>
            <div><strong>M√†u qu√¢n:</strong> <span id="colorInfo">-</span></div>
            <div><strong>ID:</strong> <span id="playerIdInfo">-</span></div>
        </div>

        <div id="waitingMessage" class="waiting" style="display:none">
            ƒêang t√¨m ƒë·ªëi th·ªß...
        </div>

        <!-- Th√™m c√°c ch·ª©c nƒÉng m·ªõi -->
        <div id="roomControls">
            <button id="createRoomBtn">T·∫°o ph√≤ng</button>
            <input type="text" id="joinRoomId" placeholder="Nh·∫≠p ID ph√≤ng">
            <button id="joinRoomBtn">Tham gia ph√≤ng</button>
            <button id="leaveRoomBtn" style="display:none;">R·ªùi ph√≤ng</button>
        </div>

        <div id="chatSection" style="display:none;">
            <div class="chat-box">
                <div id="chatMessages" class="chat-messages"></div>
                <div class="chat-input">
                    <input id="chatInput" type="text" placeholder="Nh·∫≠p tin nh·∫Øn...">
                    <button id="chatSendBtn">G·ª≠i</button>
                </div>
            </div>
        </div>

        <div id="winMessage">üéâ B·∫°n ƒë√£ th·∫Øng tr·∫≠n ƒë·∫•u!</div>

        <button id="newGameBtn">T√¨m tr·∫≠n m·ªõi</button>
    </div>
</div>

<script>
    // Game state
    let websocket = null;
    let playerId = null;
    let playerName = null;
    let yourColor = null;
    let roomId = null;
    let gameActive = false;
    let alreadyFlip = false;

    // Chess board setup
    const PIECES = {
        'r':'\u265C','n':'\u265E','b':'\u265D','q':'\u265B','k':'\u265A','p':'\u265F', // black
        'R':'\u2656','N':'\u2658','B':'\u2657','Q':'\u2655','K':'\u2654','P':'\u2659'  // white
    };

    let board = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
    ];

    let boardEl = document.getElementById('board');
    let statusEl = document.getElementById('status');
    let selected = null;
    let lastMove = null;
    let flipped = false;
    let currentTurn = 'white';

    // UI Elements
    const connectionStatusEl = document.getElementById('connectionStatus');
    const loginSectionEl = document.getElementById('loginSection');
    const gameSectionEl = document.getElementById('gameSection');
    const playerNameInput = document.getElementById('playerName');
    const connectBtn = document.getElementById('connectBtn');
    const newGameBtn = document.getElementById('newGameBtn');
    const waitingMessageEl = document.getElementById('waitingMessage');
    const roomInfoEl = document.getElementById('roomInfo');
    const colorInfoEl = document.getElementById('colorInfo');
    const playerIdInfoEl = document.getElementById('playerIdInfo');
    const createRoomBtn = document.getElementById('createRoomBtn');
    const joinRoomBtn = document.getElementById('joinRoomBtn');
    const joinRoomIdInput = document.getElementById('joinRoomId');
    const leaveRoomBtn = document.getElementById('leaveRoomBtn');
    const chatSection = document.getElementById('chatSection');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');
    const winMessage = document.getElementById('winMessage');

    // WebSocket connection
    function connect() {
        const name = playerNameInput.value.trim();
        if (!name) {
            alert('Vui l√≤ng nh·∫≠p t√™n!');
            return;
        }

        playerName = name;
        const url = "ws://localhost:8080";

        try {
            websocket = new WebSocket(url);

            websocket.onopen = () => {
                updateConnectionStatus(true);
                websocket.send(JSON.stringify({
                    type: "connect",
                    playerName: playerName
                }));
            };

            websocket.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                console.log('Received:', msg);
                handleMessage(msg);
            };

            websocket.onclose = () => {
                updateConnectionStatus(false);
                resetGameState();
            };

            websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateConnectionStatus(false);
            };

        } catch (error) {
            console.error('Connection error:', error);
            alert('Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi server!');
        }
    }
    // ==========================
    // NEW ROOM + CHAT FUNCTIONS (S·ª¨A L·∫†I)
    // ==========================

    createRoomBtn.onclick = function() {
        if(websocket && websocket.readyState === WebSocket.OPEN) {
            websocket.send(JSON.stringify({ type: "create_room" }));
        }
    };

    joinRoomBtn.onclick = function() {
        const id = joinRoomIdInput.value.trim();
        if(id && websocket && websocket.readyState === WebSocket.OPEN) {
            websocket.send(JSON.stringify({ type: "join_room", roomId: id }));
        }
    };

    leaveRoomBtn.onclick = function() {
        chatMessages.innerHTML = "";
        if(websocket && websocket.readyState === WebSocket.OPEN) {
            websocket.send(JSON.stringify({ type: "leave_room", roomId: roomId }));
        }
        resetRoomUI();
    };

    chatSendBtn.onclick = function() {
        const text = chatInput.value.trim();
        if(!text) return;
        if(websocket && websocket.readyState === WebSocket.OPEN && roomId) {
            websocket.send(JSON.stringify({ type: "chat", roomId: roomId, message: text }));
            chatInput.value = "";
        }
    };

    function addChatMessage(sender, text) {
        const div = document.createElement("div");
        div.textContent = sender + ": " + text;
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // ‚úÖ Khi ƒë√£ v√†o ph√≤ng: ch·ªâ hi·ªán chat + n√∫t R·ªùi ph√≤ng
    function showChatAndLeave() {
        chatSection.style.display = "block";
        leaveRoomBtn.style.display = "block";

        // ·∫®n t·∫•t c·∫£ c√°c n√∫t t·∫°o/tham gia khi ƒë√£ v√†o ph√≤ng
        createRoomBtn.style.display = "none";
        joinRoomBtn.style.display = "none";
        joinRoomIdInput.style.display = "none";

        newGameBtn.style.display = "none";
    }

    // ‚úÖ Khi r·ªùi ph√≤ng: hi·ªán l·∫°i c√°c n√∫t v√† textbox
    function resetRoomUI() {
        roomId = null;
        roomInfoEl.textContent = "-";
        chatSection.style.display = "none";
        leaveRoomBtn.style.display = "none";

        // Hi·ªán l·∫°i c√°c n√∫t t·∫°o/tham gia khi ch∆∞a trong tr·∫≠n
        createRoomBtn.style.display = "block";
        joinRoomBtn.style.display = "block";
        joinRoomIdInput.style.display = "block";

        newGameBtn.style.display = "block";
    }

    // ==========================

    function handleMessage(msg) {
        switch (msg.type) {
            case 'player_info':
                playerId = msg.playerId;
                playerIdInfoEl.textContent = playerId;
                loginSectionEl.style.display = 'none';
                gameSectionEl.style.display = 'block';
                waitingMessageEl.style.display = 'none';
                statusEl.textContent = 'ƒêang s·∫µn s√†ng...';
                break;

            case 'room_info':
                roomId = msg.roomId;
                roomInfoEl.textContent = roomId;
                break;

            case 'color':
                yourColor = msg.color;
                colorInfoEl.textContent = msg.color === 'white' ? 'Tr·∫Øng (ƒëi tr∆∞·ªõc)' : 'ƒêen (ƒëi sau)';
                flip();
                break;

            case 'game_start':
                gameActive = true;
                waitingMessageEl.style.display = 'none';
                newGameBtn.style.display = 'none';

                // ‚úÖ Khi tr·∫≠n b·∫Øt ƒë·∫ßu: ch·ªâ hi·ªán n√∫t R·ªùi ph√≤ng
                createRoomBtn.style.display = 'none';
                joinRoomBtn.style.display = 'none';
                joinRoomIdInput.style.display = 'none';
                chatSection.style.display = 'block';
                leaveRoomBtn.style.display = 'block';

                currentTurn = msg.currentTurn || 'white';
                updateStatus();
                resetBoard();
                break;

            case 'turn_change':
                currentTurn = msg.currentTurn;
                updateStatus();
                break;

            case 'room_created':
                roomId = msg.roomId;
                yourColor = msg.color;
                flip();
                roomInfoEl.textContent = roomId;
                showChatAndLeave();
                break;

            case 'room_joined':
                roomId = msg.roomId;
                roomInfoEl.textContent = roomId;
                yourColor = msg.color;
                flip();
                showChatAndLeave();
                break;

            case 'room_left':
                resetRoomUI();
                break;

            case 'chat':
                addChatMessage(msg.playerName || "Ng∆∞·ªùi ch∆°i", msg.message);
                break;
            case 'player_left':
            case 'player_disconnected':
                alert('ƒê·ªëi th·ªß ƒë√£ r·ªùi kh·ªèi game!');
                chatMessages.innerHTML = "";
                resetGameState();
                break;

            case 'move_result':
                if(msg.result === false) {
                    alert("N∆∞·ªõc ƒëi kh√¥ng h·ª£p l·ªá");
                } else {
                    renderFromFen(msg.fen);
                }
                break;

            case 'end_game':
                winMessage.style.display = "block";
                break;

            case 'error':
                alert('L·ªói: ' + msg.message);
                break;

            default:
                console.log('Unknown message type:', msg.type);
        }
    }

    function getPromotionPiece(color) {
        const overlay = document.getElementById('promotion-overlay');
        const pieceContainer = overlay.querySelector('.promotion-pieces');

        // T·∫°o c√°c qu√¢n c·ªù d·ª±a tr√™n m√†u
        pieceContainer.innerHTML = ''; // X√≥a c√°c qu√¢n c·ªù c≈©
        const pieces = (color === 'white') ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];

        // Tr·∫£ v·ªÅ m·ªôt Promise, code s·∫Ω "ch·ªù" cho ƒë·∫øn khi 'resolve' ƒë∆∞·ª£c g·ªçi
        return new Promise((resolve) => {
            pieces.forEach(pieceChar => {
                const pieceEl = document.createElement('div');
                pieceEl.className = 'promotion-piece';
                pieceEl.textContent = PIECES[pieceChar]; // S·ª≠ d·ª•ng ƒë·ªëi t∆∞·ª£ng PIECES to√†n c·ª•c c·ªßa b·∫°n
                pieceEl.dataset.piece = pieceChar.toUpperCase(); // Lu√¥n tr·∫£ v·ªÅ Q, R, B, N

                const clickHandler = () => {
                    // ·∫®n popup
                    overlay.classList.add('hidden');

                    // Tr·∫£ v·ªÅ qu√¢n c·ªù ƒë√£ ch·ªçn
                    resolve(pieceEl.dataset.piece);
                };

                // Th√™m tr√¨nh x·ª≠ l√Ω s·ª± ki·ªán, ch·ªâ ch·∫°y m·ªôt l·∫ßn
                pieceEl.addEventListener('click', clickHandler, { once: true });

                pieceContainer.appendChild(pieceEl);
            });

            // Hi·ªÉn th·ªã popup
            overlay.classList.remove('hidden');
        });
    }

    function parseSquare(algNotation) {
        if (!algNotation || algNotation.length !== 2) return null;
        const file = algNotation.charCodeAt(0) - 'a'.charCodeAt(0);
        const rank = 8 - parseInt(algNotation[1]);
        return { r: rank, c: file };
    }

    function coordToAlg(r, c) {
        const file = String.fromCharCode('a'.charCodeAt(0) + c);
        const rank = 8 - r;
        return file + rank;
    }

    function algToCoord(alg) {
        const c = alg.charCodeAt(0) - 'a'.charCodeAt(0);
        const r = 8 - parseInt(alg.charAt(1), 10);
        return { r, c };
    }

    function updateConnectionStatus(connected) {
        if (connected) {
            connectionStatusEl.textContent = 'ƒê√£ k·∫øt n·ªëi';
            connectionStatusEl.className = 'connection-status connected';
            newGameBtn.style.display = 'block';
            connectBtn.disabled = true;
        } else {
            connectionStatusEl.textContent = 'M·∫•t k·∫øt n·ªëi';
            connectionStatusEl.className = 'connection-status disconnected';
            connectBtn.disabled = false;
        }
    }

    function resetGameState() {
        gameActive = false;
        yourColor = null;
        roomId = null;
        currentTurn = 'white';
        waitingMessageEl.style.display = 'none';
        statusEl.textContent = 'ƒê√£ ng·∫Øt k·∫øt n·ªëi';
        resetBoard();
        render();
    }

    function resetBoard() {
        board = [
            ['r','n','b','q','k','b','n','r'],
            ['p','p','p','p','p','p','p','p'],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['P','P','P','P','P','P','P','P'],
            ['R','N','B','Q','K','B','N','R']
        ];
        selected = null;
        lastMove = null;
        render();
    }

    function render() {
        boardEl.innerHTML = '';
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const rr = flipped ? 7 - r : r;
                const cc = flipped ? 7 - c : c;

                const square = document.createElement('div');
                square.className = 'square ' + (((r + c) % 2 === 0) ? 'light' : 'dark');
                square.dataset.r = rr;
                square.dataset.c = cc;
                square.dataset.alg = coordToAlg(rr, cc);
                square.addEventListener('click', onSquareClick);

                const piece = board[rr][cc];
                if (piece) {
                    const span = document.createElement('span');
                    span.textContent = PIECES[piece] || '?';
                    span.dataset.piece = piece;
                    square.appendChild(span);
                }

                if (selected && selected.r === rr && selected.c === cc) {
                    square.classList.add('highlight');
                }

                if (lastMove &&
                    ((lastMove.from.r === rr && lastMove.from.c === cc) ||
                        (lastMove.to.r === rr && lastMove.to.c === cc))) {
                    square.classList.add('last-move');
                }

                const coord = document.createElement('div');
                coord.className = 'coords';
                coord.textContent = square.dataset.alg;
                square.appendChild(coord);

                boardEl.appendChild(square);
            }
        }
    }
    /**
     * Clears and renders the entire chessboard UI from a FEN string.
     * This version does not handle any highlighting.
     *
     * @param {string} fen The FEN string representing the board state.
     */
    function renderFromFen(fen) {
        // --- 1. Parse the FEN String to create a board layout ---
        const fenBoard = Array(8).fill(null).map(() => Array(8).fill(null));
        const [piecePlacement] = fen.split(" "); // Get the first part of the FEN

        const rows = piecePlacement.split('/');
        for (let r = 0; r < rows.length; r++) {
            const row = rows[r];
            let c = 0; // Column cursor for the current row
            for (const char of row) {
                if (isNaN(char)) {
                    // It's a piece character (e.g., 'r', 'P')
                    fenBoard[r][c] = char;
                    c++;
                } else {
                    // It's a number, so we skip that many columns
                    c += parseInt(char);
                }
            }
        }

        // --- 2. Render the board using the parsed layout ---
        boardEl.innerHTML = ''; // Clear the board first

        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const rr = flipped ? 7 - r : r;
                const cc = flipped ? 7 - c : c;

                const square = document.createElement('div');
                square.className = 'square ' + (((r + c) % 2 === 0) ? 'light' : 'dark');
                square.dataset.r = rr;
                square.dataset.c = cc;
                square.dataset.alg = coordToAlg(rr, cc);
                square.addEventListener('click', onSquareClick);

                // Get the piece from our newly created fenBoard
                const piece = fenBoard[rr][cc];
                if (piece) {
                    const span = document.createElement('span');
                    span.textContent = PIECES[piece] || '?';
                    span.dataset.piece = piece;
                    square.appendChild(span);
                }

                const coord = document.createElement('div');
                coord.className = 'coords';
                coord.textContent = square.dataset.alg;
                square.appendChild(coord);

                boardEl.appendChild(square);
            }
        }
    }

    async function onSquareClick(e) {
        if (!gameActive || !yourColor) return;
        const sq = e.currentTarget;
        const r = parseInt(sq.dataset.r);
        const c = parseInt(sq.dataset.c);
        const piece = board[r][c];
        if (currentTurn !== yourColor) return;

        if (selected) {
            if (selected.r === r && selected.c === c) {selected=null;return;}
            const selPiece = board[selected.r][selected.c];
            if (!selPiece) {selected=null;return;}
            if (piece && isPieceOurColor(piece) && selPiece.toLowerCase() !== 'k') {selected={r,c};return;}
            const selectedPiece = board[selected.r][selected.c];
            let promotionChar = null; // M·∫∑c ƒë·ªãnh l√† null

            // Ki·ªÉm tra xem ƒë√¢y c√≥ ph·∫£i l√† n∆∞·ªõc ƒëi phong c·∫•p kh√¥ng
            const isPawn = selectedPiece.toLowerCase() === 'p';
            const isLastRank = (selectedPiece === 'P' && r === 0) || (selectedPiece === 'p' && r === 7);

            if (isPawn && isLastRank) {
                // Hi·ªÉn th·ªã popup v√† CH·ªú ng∆∞·ªùi d√πng ch·ªçn
                // T·ª´ kh√≥a 'await' s·∫Ω t·∫°m d·ª´ng h√†m n√†y cho ƒë·∫øn khi Promise ƒë∆∞·ª£c resolve
                promotionChar = await getPromotionPiece(yourColor);
            }
            if(websocket && websocket.readyState === WebSocket.OPEN){
                websocket.send(JSON.stringify({
                    type:'move_request',
                    from:coordToAlg(selected.r,selected.c),
                    to:coordToAlg(r,c),
                    roomId:roomId,
                    promotion : promotionChar
                }));
            }
            selected=null;
        } else {
            if (piece && isPieceOurColor(piece)) {
                selected={r,c};
                // render();
            }
        }
    }

    function isPieceOurColor(piece) {
        if (!yourColor || !piece) return false;
        const isWhitePiece = piece === piece.toUpperCase();
        return (yourColor === 'white' && isWhitePiece) || (yourColor === 'black' && !isWhitePiece);
    }

    // function makeMove(fromAlg, toAlg) {
    //     const from = algToCoord(fromAlg);
    //     const to = algToCoord(toAlg);
    //     const { r: fr, c: fc } = from;
    //     const { r: tr, c: tc } = to;
    //     const movingPiece = board[fr][fc];
    //     if (!movingPiece) return false;
    //     board[tr][tc] = movingPiece;
    //     board[fr][fc] = '';
    //     lastMove = { from, to };
    //     render();
    //     return true;
    // }

    function makeMove(fromAlg, toAlg) {
        // B∆Ø·ªöC 1: Chuy·ªÉn ƒë·ªïi k√Ω hi·ªáu ƒë·∫°i s·ªë sang t·ªça ƒë·ªô m·∫£ng
        const from = algToCoord(fromAlg);
        const to = algToCoord(toAlg);

        // L·∫•y ch·ªâ s·ªë h√†ng, c·ªôt ƒë·ªÉ d·ªÖ s·ª≠ d·ª•ng
        const { r: fr, c: fc } = from;
        const { r: tr, c: tc } = to;

        // C√°c logic c√≤n l·∫°i gi·ªØ nguy√™n
        const movingPiece = board[fr][fc];
        const capturedPiece = board[tr][tc];

        if (!movingPiece) return false;

        // Update board
        board[tr][tc] = movingPiece;
        board[fr][fc] = ''; // '' ƒë·∫°i di·ªán cho √¥ tr·ªëng

        lastMove = { from, to, piece: movingPiece, capture: capturedPiece };

        render();
        return true;
    }

    function updateStatus() {
        if (!gameActive) {statusEl.textContent = 'Ch∆∞a c√≥ game'; return;}
        const turnText = currentTurn === 'white' ? 'Tr·∫Øng' : 'ƒêen';
        const isMyTurn = currentTurn === yourColor;
        statusEl.textContent = `L∆∞·ª£t: ${turnText}${isMyTurn ? ' (B·∫°n)' : ' (ƒê·ªëi th·ªß)'}`;
        statusEl.style.backgroundColor = isMyTurn ? '#d4edda' : '#fff3cd';
    }

    function flip() {
        if (yourColor === 'black' && !alreadyFlip) {
            flipped = !flipped;
            alreadyFlip = true;
            render();
        }
        if(yourColor === 'white' && alreadyFlip)
        {
            flipped = !flipped;
            alreadyFlip = false;
            render();
        }
    }
    function findNewGame() {
        if (websocket && websocket.readyState === WebSocket.OPEN) {
            resetGameState();
            websocket.send(JSON.stringify({type: "join",playerName: playerName}));
            waitingMessageEl.style.display = 'block';
            statusEl.textContent = 'ƒêang t√¨m ƒë·ªëi th·ªß...';
        }
    }

    connectBtn.addEventListener('click', connect);
    newGameBtn.addEventListener('click', findNewGame);
    playerNameInput.addEventListener('keypress', (e) => {if (e.key === 'Enter') connect();});
    render();
</script>
</body>
</html>
